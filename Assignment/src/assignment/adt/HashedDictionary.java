package assignment.adt; import java.io.Serializable;public class HashedDictionary<K, V> implements DictionaryInterface<K, V>, Serializable {  private TableEntry<K, V>[] hashTable;					  private int totalEntries;  private int locationsUsed;	          private static final int DEFAULT_SIZE = 101; 		   private static final double MAX_LOAD = 0.5;   public HashedDictionary() {    this(DEFAULT_SIZE);   }  public HashedDictionary(int tableSize) {		// check the table size big as user wants    int primeSize = getNextPrime(tableSize);    hashTable = new TableEntry[primeSize];    totalEntries = 0;    locationsUsed = 0;  }   public String toString() {    String output = "";    for (int i = 0; i < hashTable.length; i++) {      output += String.format("%4d. ", i);      if (hashTable[i] == null) {        output += "There is no related result.\n";      } else if (hashTable[i].isRemoved()) {        output += "The result already been removed.\n";      } else {        output += hashTable[i].getKey() + " " + hashTable[i].getValue() + "\n";      }    }     output += "\n";    return output;  }   public V add(K key, V value) {    V oldValue;     if (isHashTableOverload()) {      doubleHash();    }    int i = getHash(key);    i = probe(i, key); // check for and resolve collision    if ((hashTable[i] == null) || hashTable[i].isRemoved()) { // key not found, so insert new entry      hashTable[i] = new TableEntry<K, V>(key, value);      totalEntries++;      locationsUsed++;      oldValue = null;    } else { // key found; get old value for return and then replace it      oldValue = hashTable[i].getValue();      hashTable[i].setValue(value);    }     return oldValue;  }   public V remove(K key) {    V removedValue = null;    int i = getHash(key);    i = locate(i, key);    if (i != -1) {            removedValue = hashTable[i].getValue();      hashTable[i].setToRemoved();      totalEntries--;    }         return removedValue;  }     public V getValue(K key) {    V result = null;    int i = getHash(key);    i = locate(i, key);    if (i != -1) {      result = hashTable[i].getValue();     }		    return result;  }     private int probe(int i, K key) {    boolean found = false;    int removedStatei = -1;     while (!found && (hashTable[i] != null)) {      if (hashTable[i].isIn()) {        if (key.equals(hashTable[i].getKey())) {          found = true;         } else         {          i = (i + 1) % hashTable.length;                 }      } else {              if (removedStatei == -1) {          removedStatei = i;        }        i = (i + 1) % hashTable.length;              }     }       if (found || (removedStatei == -1)) {      return i;                 } else {      return removedStatei;     }  }     private int locate(int i, K key) {    boolean found = false;    while (!found && (hashTable[i] != null)) {      if (hashTable[i].isIn() && key.equals(hashTable[i].getKey())) {        found = true;       } else       {        i = (i + 1) % hashTable.length;               }    }     int result = -1;    if (found) {      result = i;    }    return result;  }     public boolean contains(K key) {    return getValue(key) != null;  }     public boolean isEmpty() {    return totalEntries == 0;  }   public boolean isFull() {    return false;  }   public int getSize() {    return totalEntries;  }   public final void clear() {    for (int i = 0; i < hashTable.length; i++) {      hashTable[i] = null;    }    totalEntries = 0;    locationsUsed = 0;  }  private int getHash(K key) {    int hash = key.hashCode() % hashTable.length;    if (hash < 0) {      hash = hash + hashTable.length;    }     return hash;  } //increase the size of hash table *2  private void doubleHash() {    TableEntry<K, V>[] oldTable = hashTable;    int oldSize = hashTable.length;    int newSize = getNextPrime(oldSize*2);    hashTable = new TableEntry[newSize];    totalEntries = 0;     locationsUsed = 0;    for (int i = 0; i < oldSize; i++) {      if ((oldTable[i] != null) && oldTable[i].isIn()) {        add(oldTable[i].getKey(), oldTable[i].getValue());      }    }   }  private boolean isHashTableOverload() {    return locationsUsed > MAX_LOAD * hashTable.length;  }   private int getNextPrime(int i) {    // if even, add 1 to make odd    if (i % 2 == 0) {      i++;    }     // test odd     while (!isPrime(i)) {      i = i + 2;    }    return i;  }   private boolean isPrime(int i) {    boolean result;    boolean done = false;    // 1 and even numbers are not prime    if ((i == 1) || (i % 2 == 0)) {      result = false;    }     else if ((i == 2) || (i == 3)) {      result = true;    } else { // i is odd and >= 5       // a prime is odd and not divisible by every odd i up to its square root      result = true; // assume prime      for (int divisor = 3; !done && (divisor * divisor <= i); divisor = divisor + 2) {        if (i % divisor == 0) {          result = false; // divisible; not prime          done = true;        }       }     }     return result;  }     private class TableEntry<S, T> implements Serializable {    private S key;    private T value;    private boolean inTable; // true if entry is in table    private TableEntry(S searchKey, T dataValue) {      key = searchKey;      value = dataValue;      inTable = true;    }     private S getKey() {      return key;    }    private T getValue() {      return value;    }     private void setValue(T newValue) {      value = newValue;    }     private boolean isIn() {      return inTable;    }     private boolean isRemoved() {       return !inTable;    }     private void setToRemoved() {      key = null;      value = null;      inTable = false;    }   } } 